# uppercase - terminal, lowercase - non-terminal
# you need to check your grammar even if there are no warnings

import sys
from gen_lexer import tab

GRAMMAR = {
    'const': [['INT_CONST'], ['STR_CONST'], ['BOOL_CONST']],
    'logic_op' : [['GT'], ['LT'], ['GTEQ'], ['LTEQ'], ['EQ'], ['NEQ'], ['LAND'], ['LOR']],
    'arithm_op': [['ADD'], ['SUB'], ['MUL'], ['DIV'], ['SHL'], ['SHR'], ['BOR'], ['BAND'], ['BXOR']],

    'program': [['class_def*']],
    'class_def': [['CLASS', 'TYPE', 'inherits?', 'LBRACE', 'attrib_decl*', 'method*', 'RBRACE']],
    'inherits': [['COLON', 'TYPE']],
    'attrib_decl': [['TYPE', 'ID', 'attrib_tail*', 'SCOLON']],
    'attrib_tail': [['COMMA', 'ID']],
    'method': [['DEF', 'TYPE', 'ID', 'LPARENTH', 'params?', 'RPARENTH', 'block']],
    'params': [['TYPE', 'ID', 'params_tail*']],
    'params_tail': [['COMMA', 'TYPE', 'ID']],
    'var_decl': [['TYPE', 'ID', 'initialization?', 'var_tail*', 'SCOLON']],
    'var_tail': [['COMMA', 'ID', 'initialization?']],
    'initialization': [['ASSIGN', 'rval']],
    'block': [['expr'], ['LBRACE', 'expr*', 'RBRACE']],

    'expr': [['ptr_expr'], ['if_expr'], ['while_expr'], ['for_expr'],
             ['switch_expr'], ['return_expr'], ['asm_expr'], ['ctrl_expr'], 
             ['var_decl']],
    'ptr_expr': [['ptr', 'initialization', 'SCOLON'], ['call', 'SCOLON']],
    'if_expr': [['IF', 'LPARENTH', 'rval', 'RPARENTH', 'block', 'else_block?']],
    'else_block': [['ELSE', 'block']],
    'while_expr': [['WHILE', 'LPARENTH', 'rval', 'RPARENTH', 'block']],
    'for_expr': [['FOR', 'LPARENTH', 'ptr_expr', 'rval', 'SCOLON', 'block', 'RPARENTH', 'block']],
    'switch_expr': [['SWITCH', 'LPARENTH', 'rval', 'RPARENTH', 'LBRACE', 'case_expr*', 'default_case?', 'RBRACE']],
    'case_expr': [['CASE', 'INT_CONST', 'COLON', 'block']],
    'default_case': [['DEFAULT', 'COLON', 'block']],
    'asm_expr': [['ASM', 'LPARENTH', 'STR_CONST', 'RPARENTH', 'SCOLON']],
    'ctrl_expr': [['BREAK', 'SCOLON'], ['CONTINUE', 'SCOLON']],
    'return_expr': [['RETURN', 'rval?', 'SCOLON']],

    'ptr': [['ID', 'class_ptr?'], ['alloc']],
    'class_ptr': [['DOT', 'ptr']],
    
    'call': [['CALL', 'ptr', 'LPARENTH', 'args?', 'RPARENTH']],
    'args': [['rval', 'args_tail*']],
    'args_tail': [['COMMA', 'rval']],

    'rval': [['rval_tail', 'arithm_tail?']],
    'alloc': [['NEW', 'TYPE']],
    'rval_tail': [['factor', 'logic_tail?']],
    'factor': [['LNOT', 'rval'], ['BNOT', 'rval'],
        ['LPARENTH', 'rval', 'RPARENTH'],
        ['cast'], ['const'], ['ptr'], ['call'], ['THIS']],
    'cast': [['CAST', 'LT', 'TYPE', 'GT', 'LPARENTH', 'rval', 'RPARENTH']],
    'logic_tail': [['logic_op', 'rval_tail']],
    'arithm_tail': [['arithm_op', 'rval']],
}

# for error reporting, appended after symbol is accepted
ACTIONS = {
    'class_def': {
        'CLASS': '%sif(peek(TYPE)) className = curr().strVal();' % tab(2),
        'RBRACE': '%sclassName = "";' % tab(2)
    },
    'method': {
        'TYPE': '%sif(peek(ID)) methodName = curr().strVal(); blockNo = 0;' % tab(2),
        'block': '%smethodName = "";' % tab(2)
    },
    'block': {
        'LBRACE': '%sblockNo++;' % tab(2)
    }
}

HEADER = '''/* autogenerated by parser.py */
#ifndef __PARSER_H__
#define __PARSER_H__

#include "Lexer.h"

#include <iostream>
#include <fstream>
#include <streambuf>
#include <string>

#define PARSER_ERR_NOLINE(msg, ...) fprintf(stderr, "[Parser] " msg "\\n", __VA_ARGS__)
#define PARSER_ERR(msg, ...) fprintf(stderr, "[Parser] at line %%d: " msg "\\n", next->lineNo, __VA_ARGS__)

class Parser {
    Token* next, *last, *save;
    
    bool traverse_tree() {
        next = &lexer.tokens[0];
        last = next + lexer.tokens.size();
        return p_program();
    }
protected:
    Lexer lexer;    
public:
    Parser() : next(NULL), last(NULL), save(NULL) { }
    
    virtual bool parse(const std::string& str) {
        return lexer.lex(str) && traverse_tree();
    }    
protected:
    /* inside which class, method and block we are currently */
    std::string className, methodName;
    int blockNo;
    
    /* checks if current token is of type "type" */
    bool peek(TokenType type) const {
        return next && next->type == type;
    }
    
    /* moves to the next token if current one is the expected one */
    bool accept(TokenType type) {
        if(!next || next == last) {
            PARSER_ERR_NOLINE("in %%s::%%s: EOF when %%s expected", className.c_str(), methodName.c_str(), Token::typeToString(type));
            return false;
        }
        if(next->type == type) {
            next++;
            return true;
        }
        PARSER_ERR("%%s expected, but %%s found", Token::typeToString(type), next->toString());
        return false;
    }
    
    /* current element text value */
    const Token& curr() const {
        return *next;
    }

    /* marks current position in tokens list */
    void mark() {
        save = next;
    }

    /* resets position to marked position */
    void reset() {
        next = save;
    }

    /* forward declarations */
%s
};
'''

FOOTER = '#endif\n'


def is_term(symbol):
    return symbol.upper() == symbol

def non_term_name(symbol):
    if symbol.endswith('*') or symbol.endswith('?'): return symbol[:-1]
    else: return symbol

class Terminals:
    def __init__(self, symbol):
        if is_term(symbol): self.terms = [symbol]
        else:
            symbol = non_term_name(symbol)
            self.terms = [non_term_name(alt[0]) for alt in GRAMMAR[symbol]]
            for x in GRAMMAR[symbol]:
                if not is_term(x[0]):
                    i = 1
                    while i < len(x) and (x[i].endswith('*') or x[i].endswith('?')):
                        self.terms.append(non_term_name(x[i]))
                        i += 1
                    
            while not self.allTerm():            
                nonTerms = [x for x in self.terms if not is_term(x)]
                self.terms = [x for x in self.terms if is_term(x)]
                for nonTerm in nonTerms:
                    self.terms.extend([alt[0] for alt in GRAMMAR[non_term_name(nonTerm)]])
        if len(self.terms) == 0:
            raise Exception('No terminals')
        if(len(self.terms) != len(set(self.terms))):
            sys.stderr.write('Warning: ambigious grammar for %s: %s\r\n' % (symbol, ' '.join(self.terms)))
            
    def allTerm(self):
        for symbol in self.terms:
            if not is_term(symbol): return False
        return True
    
    def cond(self):
        if len(self.terms) == 1: return 'peek(%s)' % self.terms[0]
        else:
            code = ''
            for term in self.terms:
                code += 'peek(%s) || ' % term
            code = code[:-4]
            return code

def generate():
    forward_decl_code = ''
    for product in GRAMMAR: # forward definitions
        forward_decl_code += '    virtual bool p_%s();\n' % product

    print(HEADER) % (forward_decl_code)

    for product in GRAMMAR:
        code = 'bool Parser::p_%s() {\n' % product
        #code += '    puts("%s");\n' % product
        for alternative in GRAMMAR[product]:
            code += '%sif(%s) {\n' % (tab(1), Terminals(alternative[0]).cond())
            for symbol in alternative:
                if is_term(symbol):
                    code += '%sif(!accept(%s)) return false;\n' % (tab(2), symbol)
                elif symbol.endswith('*'):
                    symbol = non_term_name(symbol)
                    code += '%swhile(%s) {\n' % (tab(2), Terminals(non_term_name(symbol)).cond())
                    code += '%sif(!p_%s()) return false;\n' % (tab(3), symbol)
                    code += '%s}\n' % tab(2)
                elif symbol.endswith('?'):
                    symbol = non_term_name(symbol)
                    code += '%sif((%s) && !p_%s()) return false;\n' % (tab(2), Terminals(non_term_name(symbol)).cond(), symbol)
                else:
                    code += '%sif(!p_%s()) return false;\n' % (tab(2), symbol)
                if product in ACTIONS and symbol in ACTIONS[product]:
                    code += ACTIONS[product][symbol] + '\n'
            code += '%sreturn true;\n%s}\n' % (tab(2), tab(1))
        code += '%sPARSER_ERR("expected %s but %%s found", next->toString());\n' % (tab(1), ' or '.join(Terminals(product).terms))
        code += '%sreturn false;\n}\n' % tab(1)
        print(code)
    print(FOOTER)

if __name__ == '__main__':
    generate()