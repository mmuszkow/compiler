/* autogenerated by parser.py */
#ifndef __PARSER_H__
#define __PARSER_H__

#include "Lexer.h"

#include <iostream>
#include <fstream>
#include <streambuf>
#include <string>

#define PARSER_ERR_NOLINE(msg, ...) fprintf(stderr, "[Parser] " msg "\n", __VA_ARGS__)
#define PARSER_ERR(msg, ...) fprintf(stderr, "[Parser] at line %d: " msg "\n", next->lineNo, __VA_ARGS__)

class Parser {
    Token* next, *last, *save;
    
    bool traverse_tree() {
        next = &lexer.tokens[0];
        last = next + lexer.tokens.size();
        return p_program();
    }
protected:
    Lexer lexer;    
public:
    Parser() : next(NULL), last(NULL), save(NULL) { }
    
    virtual bool parse(const std::string& str) {
        return lexer.lex(str) && traverse_tree();
    }    
protected:
    /* inside which class, method and block we are currently */
    std::string className, methodName;
    int blockNo;
    
    /* checks if current token is of type "type" */
    bool peek(TokenType type) const {
        return next && next->type == type;
    }
    
    /* moves to the next token if current one is the expected one */
    bool accept(TokenType type) {
        if(!next || next == last) {
            PARSER_ERR_NOLINE("in %s::%s: EOF when %s expected", className.c_str(), methodName.c_str(), Token::typeToString(type));
            return false;
        }
        if(next->type == type) {
            next++;
            return true;
        }
        PARSER_ERR("%s expected, but %s found", Token::typeToString(type), next->toString());
        return false;
    }
    
    /* current element text value */
    const Token& curr() const {
        return *next;
    }

    /* marks current position in tokens list */
    void mark() {
        save = next;
    }

    /* resets position to marked position */
    void reset() {
        next = save;
    }

    /* forward declarations */
    virtual bool p_inherits();
    virtual bool p_args();
    virtual bool p_case_expr();
    virtual bool p_while_expr();
    virtual bool p_initialization();
    virtual bool p_return_expr();
    virtual bool p_var_tail();
    virtual bool p_if_expr();
    virtual bool p_attrib_decl();
    virtual bool p_args_tail();
    virtual bool p_default_case();
    virtual bool p_logic_op();
    virtual bool p_ptr_expr();
    virtual bool p_ptr();
    virtual bool p_attrib_tail();
    virtual bool p_else_block();
    virtual bool p_params_tail();
    virtual bool p_logic_tail();
    virtual bool p_arithm_op();
    virtual bool p_arithm_tail();
    virtual bool p_const();
    virtual bool p_cast();
    virtual bool p_expr();
    virtual bool p_rval();
    virtual bool p_asm_expr();
    virtual bool p_var_decl();
    virtual bool p_method();
    virtual bool p_rval_tail();
    virtual bool p_program();
    virtual bool p_params();
    virtual bool p_for_expr();
    virtual bool p_factor();
    virtual bool p_call();
    virtual bool p_class_ptr();
    virtual bool p_ctrl_expr();
    virtual bool p_alloc();
    virtual bool p_class_def();
    virtual bool p_block();
    virtual bool p_switch_expr();

};

bool Parser::p_inherits() {
    if(peek(COLON)) {
        if(!accept(COLON)) return false;
        if(!accept(TYPE)) return false;
        return true;
    }
    PARSER_ERR("expected COLON but %s found", next->toString());
    return false;
}

bool Parser::p_args() {
    if(peek(LNOT) || peek(BNOT) || peek(LPARENTH) || peek(THIS) || peek(ADD) || peek(SUB) || peek(MUL) || peek(DIV) || peek(SHL) || peek(SHR) || peek(BOR) || peek(BAND) || peek(BXOR) || peek(CAST) || peek(INT_CONST) || peek(STR_CONST) || peek(BOOL_CONST) || peek(ID) || peek(CALL) || peek(NEW)) {
        if(!p_rval()) return false;
        while(peek(COMMA)) {
            if(!p_args_tail()) return false;
        }
        return true;
    }
    PARSER_ERR("expected COMMA or LNOT or BNOT or LPARENTH or THIS or CAST or INT_CONST or STR_CONST or BOOL_CONST or ID or CALL or NEW but %s found", next->toString());
    return false;
}

bool Parser::p_case_expr() {
    if(peek(CASE)) {
        if(!accept(CASE)) return false;
        if(!accept(INT_CONST)) return false;
        if(!accept(COLON)) return false;
        if(!p_block()) return false;
        return true;
    }
    PARSER_ERR("expected CASE but %s found", next->toString());
    return false;
}

bool Parser::p_while_expr() {
    if(peek(WHILE)) {
        if(!accept(WHILE)) return false;
        if(!accept(LPARENTH)) return false;
        if(!p_rval()) return false;
        if(!accept(RPARENTH)) return false;
        if(!p_block()) return false;
        return true;
    }
    PARSER_ERR("expected WHILE but %s found", next->toString());
    return false;
}

bool Parser::p_initialization() {
    if(peek(ASSIGN)) {
        if(!accept(ASSIGN)) return false;
        if(!p_rval()) return false;
        return true;
    }
    PARSER_ERR("expected ASSIGN but %s found", next->toString());
    return false;
}

bool Parser::p_return_expr() {
    if(peek(RETURN)) {
        if(!accept(RETURN)) return false;
        if((peek(LNOT) || peek(BNOT) || peek(LPARENTH) || peek(THIS) || peek(ADD) || peek(SUB) || peek(MUL) || peek(DIV) || peek(SHL) || peek(SHR) || peek(BOR) || peek(BAND) || peek(BXOR) || peek(CAST) || peek(INT_CONST) || peek(STR_CONST) || peek(BOOL_CONST) || peek(ID) || peek(CALL) || peek(NEW)) && !p_rval()) return false;
        if(!accept(SCOLON)) return false;
        return true;
    }
    PARSER_ERR("expected RETURN but %s found", next->toString());
    return false;
}

bool Parser::p_var_tail() {
    if(peek(COMMA)) {
        if(!accept(COMMA)) return false;
        if(!accept(ID)) return false;
        if((peek(ASSIGN)) && !p_initialization()) return false;
        return true;
    }
    PARSER_ERR("expected COMMA but %s found", next->toString());
    return false;
}

bool Parser::p_if_expr() {
    if(peek(IF)) {
        if(!accept(IF)) return false;
        if(!accept(LPARENTH)) return false;
        if(!p_rval()) return false;
        if(!accept(RPARENTH)) return false;
        if(!p_block()) return false;
        if((peek(ELSE)) && !p_else_block()) return false;
        return true;
    }
    PARSER_ERR("expected IF but %s found", next->toString());
    return false;
}

bool Parser::p_attrib_decl() {
    if(peek(TYPE)) {
        if(!accept(TYPE)) return false;
        if(!accept(ID)) return false;
        while(peek(COMMA)) {
            if(!p_attrib_tail()) return false;
        }
        if(!accept(SCOLON)) return false;
        return true;
    }
    PARSER_ERR("expected TYPE but %s found", next->toString());
    return false;
}

bool Parser::p_args_tail() {
    if(peek(COMMA)) {
        if(!accept(COMMA)) return false;
        if(!p_rval()) return false;
        return true;
    }
    PARSER_ERR("expected COMMA but %s found", next->toString());
    return false;
}

bool Parser::p_default_case() {
    if(peek(DEFAULT)) {
        if(!accept(DEFAULT)) return false;
        if(!accept(COLON)) return false;
        if(!p_block()) return false;
        return true;
    }
    PARSER_ERR("expected DEFAULT but %s found", next->toString());
    return false;
}

bool Parser::p_logic_op() {
    if(peek(GT)) {
        if(!accept(GT)) return false;
        return true;
    }
    if(peek(LT)) {
        if(!accept(LT)) return false;
        return true;
    }
    if(peek(GTEQ)) {
        if(!accept(GTEQ)) return false;
        return true;
    }
    if(peek(LTEQ)) {
        if(!accept(LTEQ)) return false;
        return true;
    }
    if(peek(EQ)) {
        if(!accept(EQ)) return false;
        return true;
    }
    if(peek(NEQ)) {
        if(!accept(NEQ)) return false;
        return true;
    }
    if(peek(LAND)) {
        if(!accept(LAND)) return false;
        return true;
    }
    if(peek(LOR)) {
        if(!accept(LOR)) return false;
        return true;
    }
    PARSER_ERR("expected GT or LT or GTEQ or LTEQ or EQ or NEQ or LAND or LOR but %s found", next->toString());
    return false;
}

bool Parser::p_ptr_expr() {
    if(peek(ID) || peek(NEW)) {
        if(!p_ptr()) return false;
        if(!p_initialization()) return false;
        if(!accept(SCOLON)) return false;
        return true;
    }
    if(peek(CALL)) {
        if(!p_call()) return false;
        if(!accept(SCOLON)) return false;
        return true;
    }
    PARSER_ERR("expected ID or CALL or NEW but %s found", next->toString());
    return false;
}

bool Parser::p_ptr() {
    if(peek(ID)) {
        if(!accept(ID)) return false;
        if((peek(DOT)) && !p_class_ptr()) return false;
        return true;
    }
    if(peek(NEW)) {
        if(!p_alloc()) return false;
        return true;
    }
    PARSER_ERR("expected ID or NEW but %s found", next->toString());
    return false;
}

bool Parser::p_attrib_tail() {
    if(peek(COMMA)) {
        if(!accept(COMMA)) return false;
        if(!accept(ID)) return false;
        return true;
    }
    PARSER_ERR("expected COMMA but %s found", next->toString());
    return false;
}

bool Parser::p_else_block() {
    if(peek(ELSE)) {
        if(!accept(ELSE)) return false;
        if(!p_block()) return false;
        return true;
    }
    PARSER_ERR("expected ELSE but %s found", next->toString());
    return false;
}

bool Parser::p_params_tail() {
    if(peek(COMMA)) {
        if(!accept(COMMA)) return false;
        if(!accept(TYPE)) return false;
        if(!accept(ID)) return false;
        return true;
    }
    PARSER_ERR("expected COMMA but %s found", next->toString());
    return false;
}

bool Parser::p_logic_tail() {
    if(peek(GT) || peek(LT) || peek(GTEQ) || peek(LTEQ) || peek(EQ) || peek(NEQ) || peek(LAND) || peek(LOR)) {
        if(!p_logic_op()) return false;
        if(!p_rval_tail()) return false;
        return true;
    }
    PARSER_ERR("expected GT or LT or GTEQ or LTEQ or EQ or NEQ or LAND or LOR but %s found", next->toString());
    return false;
}

bool Parser::p_arithm_op() {
    if(peek(ADD)) {
        if(!accept(ADD)) return false;
        return true;
    }
    if(peek(SUB)) {
        if(!accept(SUB)) return false;
        return true;
    }
    if(peek(MUL)) {
        if(!accept(MUL)) return false;
        return true;
    }
    if(peek(DIV)) {
        if(!accept(DIV)) return false;
        return true;
    }
    if(peek(SHL)) {
        if(!accept(SHL)) return false;
        return true;
    }
    if(peek(SHR)) {
        if(!accept(SHR)) return false;
        return true;
    }
    if(peek(BOR)) {
        if(!accept(BOR)) return false;
        return true;
    }
    if(peek(BAND)) {
        if(!accept(BAND)) return false;
        return true;
    }
    if(peek(BXOR)) {
        if(!accept(BXOR)) return false;
        return true;
    }
    PARSER_ERR("expected ADD or SUB or MUL or DIV or SHL or SHR or BOR or BAND or BXOR but %s found", next->toString());
    return false;
}

bool Parser::p_arithm_tail() {
    if(peek(ADD) || peek(SUB) || peek(MUL) || peek(DIV) || peek(SHL) || peek(SHR) || peek(BOR) || peek(BAND) || peek(BXOR)) {
        if(!p_arithm_op()) return false;
        if(!p_rval()) return false;
        return true;
    }
    PARSER_ERR("expected ADD or SUB or MUL or DIV or SHL or SHR or BOR or BAND or BXOR but %s found", next->toString());
    return false;
}

bool Parser::p_const() {
    if(peek(INT_CONST)) {
        if(!accept(INT_CONST)) return false;
        return true;
    }
    if(peek(STR_CONST)) {
        if(!accept(STR_CONST)) return false;
        return true;
    }
    if(peek(BOOL_CONST)) {
        if(!accept(BOOL_CONST)) return false;
        return true;
    }
    PARSER_ERR("expected INT_CONST or STR_CONST or BOOL_CONST but %s found", next->toString());
    return false;
}

bool Parser::p_cast() {
    if(peek(CAST)) {
        if(!accept(CAST)) return false;
        if(!accept(LT)) return false;
        if(!accept(TYPE)) return false;
        if(!accept(GT)) return false;
        if(!accept(LPARENTH)) return false;
        if(!p_rval()) return false;
        if(!accept(RPARENTH)) return false;
        return true;
    }
    PARSER_ERR("expected CAST but %s found", next->toString());
    return false;
}

bool Parser::p_expr() {
    if(peek(ID) || peek(CALL) || peek(NEW)) {
        if(!p_ptr_expr()) return false;
        return true;
    }
    if(peek(IF)) {
        if(!p_if_expr()) return false;
        return true;
    }
    if(peek(WHILE)) {
        if(!p_while_expr()) return false;
        return true;
    }
    if(peek(FOR)) {
        if(!p_for_expr()) return false;
        return true;
    }
    if(peek(SWITCH)) {
        if(!p_switch_expr()) return false;
        return true;
    }
    if(peek(RETURN)) {
        if(!p_return_expr()) return false;
        return true;
    }
    if(peek(ASM)) {
        if(!p_asm_expr()) return false;
        return true;
    }
    if(peek(BREAK) || peek(CONTINUE)) {
        if(!p_ctrl_expr()) return false;
        return true;
    }
    if(peek(TYPE)) {
        if(!p_var_decl()) return false;
        return true;
    }
    PARSER_ERR("expected IF or WHILE or FOR or SWITCH or RETURN or ASM or BREAK or CONTINUE or TYPE or ID or CALL or NEW but %s found", next->toString());
    return false;
}

bool Parser::p_rval() {
    if(peek(LNOT) || peek(BNOT) || peek(LPARENTH) || peek(THIS) || peek(CAST) || peek(INT_CONST) || peek(STR_CONST) || peek(BOOL_CONST) || peek(ID) || peek(CALL) || peek(GT) || peek(LT) || peek(GTEQ) || peek(LTEQ) || peek(EQ) || peek(NEQ) || peek(LAND) || peek(LOR) || peek(NEW)) {
        if(!p_rval_tail()) return false;
        if((peek(ADD) || peek(SUB) || peek(MUL) || peek(DIV) || peek(SHL) || peek(SHR) || peek(BOR) || peek(BAND) || peek(BXOR)) && !p_arithm_tail()) return false;
        return true;
    }
    PARSER_ERR("expected LNOT or BNOT or LPARENTH or THIS or ADD or SUB or MUL or DIV or SHL or SHR or BOR or BAND or BXOR or CAST or INT_CONST or STR_CONST or BOOL_CONST or ID or CALL or NEW but %s found", next->toString());
    return false;
}

bool Parser::p_asm_expr() {
    if(peek(ASM)) {
        if(!accept(ASM)) return false;
        if(!accept(LPARENTH)) return false;
        if(!accept(STR_CONST)) return false;
        if(!accept(RPARENTH)) return false;
        if(!accept(SCOLON)) return false;
        return true;
    }
    PARSER_ERR("expected ASM but %s found", next->toString());
    return false;
}

bool Parser::p_var_decl() {
    if(peek(TYPE)) {
        if(!accept(TYPE)) return false;
        if(!accept(ID)) return false;
        if((peek(ASSIGN)) && !p_initialization()) return false;
        while(peek(COMMA)) {
            if(!p_var_tail()) return false;
        }
        if(!accept(SCOLON)) return false;
        return true;
    }
    PARSER_ERR("expected TYPE but %s found", next->toString());
    return false;
}

bool Parser::p_method() {
    if(peek(DEF)) {
        if(!accept(DEF)) return false;
        if(!accept(TYPE)) return false;
        if(peek(ID)) methodName = curr().strVal(); blockNo = 0;
        if(!accept(ID)) return false;
        if(!accept(LPARENTH)) return false;
        if((peek(TYPE)) && !p_params()) return false;
        if(!accept(RPARENTH)) return false;
        if(!p_block()) return false;
        methodName = "";
        return true;
    }
    PARSER_ERR("expected DEF but %s found", next->toString());
    return false;
}

bool Parser::p_rval_tail() {
    if(peek(LNOT) || peek(BNOT) || peek(LPARENTH) || peek(THIS) || peek(CAST) || peek(INT_CONST) || peek(STR_CONST) || peek(BOOL_CONST) || peek(ID) || peek(CALL) || peek(NEW)) {
        if(!p_factor()) return false;
        if((peek(GT) || peek(LT) || peek(GTEQ) || peek(LTEQ) || peek(EQ) || peek(NEQ) || peek(LAND) || peek(LOR)) && !p_logic_tail()) return false;
        return true;
    }
    PARSER_ERR("expected LNOT or BNOT or LPARENTH or THIS or CAST or INT_CONST or STR_CONST or BOOL_CONST or ID or CALL or GT or LT or GTEQ or LTEQ or EQ or NEQ or LAND or LOR or NEW but %s found", next->toString());
    return false;
}

bool Parser::p_program() {
    if(peek(CLASS)) {
        while(peek(CLASS)) {
            if(!p_class_def()) return false;
        }
        return true;
    }
    PARSER_ERR("expected CLASS but %s found", next->toString());
    return false;
}

bool Parser::p_params() {
    if(peek(TYPE)) {
        if(!accept(TYPE)) return false;
        if(!accept(ID)) return false;
        while(peek(COMMA)) {
            if(!p_params_tail()) return false;
        }
        return true;
    }
    PARSER_ERR("expected TYPE but %s found", next->toString());
    return false;
}

bool Parser::p_for_expr() {
    if(peek(FOR)) {
        if(!accept(FOR)) return false;
        if(!accept(LPARENTH)) return false;
        if(!p_ptr_expr()) return false;
        if(!p_rval()) return false;
        if(!accept(SCOLON)) return false;
        if(!p_block()) return false;
        if(!accept(RPARENTH)) return false;
        if(!p_block()) return false;
        return true;
    }
    PARSER_ERR("expected FOR but %s found", next->toString());
    return false;
}

bool Parser::p_factor() {
    if(peek(LNOT)) {
        if(!accept(LNOT)) return false;
        if(!p_rval()) return false;
        return true;
    }
    if(peek(BNOT)) {
        if(!accept(BNOT)) return false;
        if(!p_rval()) return false;
        return true;
    }
    if(peek(LPARENTH)) {
        if(!accept(LPARENTH)) return false;
        if(!p_rval()) return false;
        if(!accept(RPARENTH)) return false;
        return true;
    }
    if(peek(CAST)) {
        if(!p_cast()) return false;
        return true;
    }
    if(peek(INT_CONST) || peek(STR_CONST) || peek(BOOL_CONST)) {
        if(!p_const()) return false;
        return true;
    }
    if(peek(ID) || peek(NEW)) {
        if(!p_ptr()) return false;
        return true;
    }
    if(peek(CALL)) {
        if(!p_call()) return false;
        return true;
    }
    if(peek(THIS)) {
        if(!accept(THIS)) return false;
        return true;
    }
    PARSER_ERR("expected LNOT or BNOT or LPARENTH or THIS or CAST or INT_CONST or STR_CONST or BOOL_CONST or ID or CALL or NEW but %s found", next->toString());
    return false;
}

bool Parser::p_call() {
    if(peek(CALL)) {
        if(!accept(CALL)) return false;
        if(!p_ptr()) return false;
        if(!accept(LPARENTH)) return false;
        if((peek(COMMA) || peek(LNOT) || peek(BNOT) || peek(LPARENTH) || peek(THIS) || peek(CAST) || peek(INT_CONST) || peek(STR_CONST) || peek(BOOL_CONST) || peek(ID) || peek(CALL) || peek(NEW)) && !p_args()) return false;
        if(!accept(RPARENTH)) return false;
        return true;
    }
    PARSER_ERR("expected CALL but %s found", next->toString());
    return false;
}

bool Parser::p_class_ptr() {
    if(peek(DOT)) {
        if(!accept(DOT)) return false;
        if(!p_ptr()) return false;
        return true;
    }
    PARSER_ERR("expected DOT but %s found", next->toString());
    return false;
}

bool Parser::p_ctrl_expr() {
    if(peek(BREAK)) {
        if(!accept(BREAK)) return false;
        if(!accept(SCOLON)) return false;
        return true;
    }
    if(peek(CONTINUE)) {
        if(!accept(CONTINUE)) return false;
        if(!accept(SCOLON)) return false;
        return true;
    }
    PARSER_ERR("expected BREAK or CONTINUE but %s found", next->toString());
    return false;
}

bool Parser::p_alloc() {
    if(peek(NEW)) {
        if(!accept(NEW)) return false;
        if(!accept(TYPE)) return false;
        return true;
    }
    PARSER_ERR("expected NEW but %s found", next->toString());
    return false;
}

bool Parser::p_class_def() {
    if(peek(CLASS)) {
        if(!accept(CLASS)) return false;
        if(peek(TYPE)) className = curr().strVal();
        if(!accept(TYPE)) return false;
        if((peek(COLON)) && !p_inherits()) return false;
        if(!accept(LBRACE)) return false;
        while(peek(TYPE)) {
            if(!p_attrib_decl()) return false;
        }
        while(peek(DEF)) {
            if(!p_method()) return false;
        }
        if(!accept(RBRACE)) return false;
        className = "";
        return true;
    }
    PARSER_ERR("expected CLASS but %s found", next->toString());
    return false;
}

bool Parser::p_block() {
    if(peek(IF) || peek(WHILE) || peek(FOR) || peek(SWITCH) || peek(RETURN) || peek(ASM) || peek(BREAK) || peek(CONTINUE) || peek(TYPE) || peek(ID) || peek(CALL) || peek(NEW)) {
        if(!p_expr()) return false;
        return true;
    }
    if(peek(LBRACE)) {
        if(!accept(LBRACE)) return false;
        blockNo++;
        while(peek(IF) || peek(WHILE) || peek(FOR) || peek(SWITCH) || peek(RETURN) || peek(ASM) || peek(BREAK) || peek(CONTINUE) || peek(TYPE) || peek(ID) || peek(CALL) || peek(NEW)) {
            if(!p_expr()) return false;
        }
        if(!accept(RBRACE)) return false;
        return true;
    }
    PARSER_ERR("expected LBRACE or IF or WHILE or FOR or SWITCH or RETURN or ASM or BREAK or CONTINUE or TYPE or ID or CALL or NEW but %s found", next->toString());
    return false;
}

bool Parser::p_switch_expr() {
    if(peek(SWITCH)) {
        if(!accept(SWITCH)) return false;
        if(!accept(LPARENTH)) return false;
        if(!p_rval()) return false;
        if(!accept(RPARENTH)) return false;
        if(!accept(LBRACE)) return false;
        while(peek(CASE)) {
            if(!p_case_expr()) return false;
        }
        if((peek(DEFAULT)) && !p_default_case()) return false;
        if(!accept(RBRACE)) return false;
        return true;
    }
    PARSER_ERR("expected SWITCH but %s found", next->toString());
    return false;
}

#endif

