/* autogenerated by codegen.py, code generation assumes that AST is correct */
#ifndef __CODEGEN_H__
#define __CODEGEN_H__

#include "SemanticCheck.h"
#include <set>

#define CG_ASM(fmt, ...) fprintf(out, fmt "\n", __VA_ARGS__)

// second pass has the info about the type
class CodeGen : public Parser {
    FILE* out;
    static int uniqueId;

    /* for break and continue, TODO: add to semantic checker */
    std::string ctrlEnd, ctrlBegin;
    /* for used string constants */
    std::set<int> str_consts;

    SemanticCheck sc;

    /* processor word size in bytes */
    static const int WORD_SIZE = 4;
public:
    CodeGen(FILE* _out) : out(_out) { }

    bool parse(const std::string& str) {
        str_consts.clear();        
        return sc.parse(str) && Parser::parse(str);
    }
protected:
    std::string type, id;

    // puts the adress in ebx, value in eax
    void var(bool isLocal) {
        if(isLocal) {
            const Method& m = sc.getMethod(className, methodName);
            if(sc.isLocalVar(className, methodName, id)) {
                type = sc.getType(className, methodName, id);
                CG_ASM("  mov ebx, ebp");
                CG_ASM("  sub ebx, %d", (m.localOffset(id)+2)*WORD_SIZE); // local vars are pushed on the stack in the beginning of function
                CG_ASM("  mov eax, [ebx]");
            } else if(sc.isMethodArg(className, methodName, id)) {
                type = sc.getType(className, methodName, id);
                CG_ASM("  mov ebx, ebp");
                CG_ASM("  add ebx, %d", (m.params.size()-m.paramOffset(id)+1) * WORD_SIZE, id.c_str()); // 1 word for return addr, 1 for prev ebp
                CG_ASM("  mov eax, [ebx]");
            } else if(sc.isAttribute(className, id)) {
                type = sc.getType(className, methodName, id);
                const Class& c = sc.getClass(className);
                CG_ASM("  mov ebx, [ebp+%d]", (m.params.size()+2)*WORD_SIZE); // this pointer is the last argument
                if(c.attribOffset(id) > 0)
                    CG_ASM("  add ebx, %d", c.attribOffset(id) * WORD_SIZE);
                CG_ASM("  mov eax, [ebx]");
            } else {
                // method call, this is handled in p_call
            }
        } else {
            if(sc.isAttribute(type, id)) {
                const Class& c= sc.getClass(type);
                type = sc.getClass(type).attributes.at(id).type;
                CG_ASM("  mov ebx, eax");
                if(c.attribOffset(id) > 0)
                    CG_ASM("  add ebx, %d", c.attribOffset(id) * WORD_SIZE);
                CG_ASM("  mov eax, [ebx]");
            } else {
                // method call, this is handled in p_call
            }
        }
    }

    bool p_call() {
        accept(CALL);
        p_ptr();

        // class instance ptr
        std::string methodClass = type;
        const Method& m = sc.getMethod(methodClass, id);
        if(methodClass == className) {// this call
            const Method& thisM = sc.getMethod(className, methodName);
            CG_ASM("  push [ebp+%d]", (thisM.params.size()+2) * WORD_SIZE); // this pointer is the last argument
        } else
            CG_ASM("  push eax");

        // arguments
        accept(LPARENTH);
        if(peek(COMMA) || peek(NEW) || peek(LNOT) || peek(BNOT) || peek(LPARENTH) 
            || peek(THIS) || peek(CAST) || peek(INT_CONST) || peek(STR_CONST)
            || peek(BOOL_CONST) || peek(ID) || peek(CALL)) 
            p_args();
        accept(RPARENTH);

        CG_ASM("  call %s_%s", methodClass.c_str(), m.name.c_str());
        CG_ASM("  add esp, %d", (m.params.size() + 1) * WORD_SIZE); // pop args + instance pointer        
        return true;
    }

    bool p_ptr() {
        if(peek(ID)) {
            id = curr().strVal();
            type = className;
            accept(ID);
            var(true);        
            while(peek(DOT)) {
                accept(DOT);            
                id = curr().strVal();
                accept(ID);
                var(false);
            }
            return true;
        }
        return Parser::p_ptr();
    }

    bool p_ptr_expr() {
        if(peek(ID)) {
            p_ptr();
            CG_ASM("  push ebx");
            p_initialization();
            accept(SCOLON);
            CG_ASM("  pop ebx");
            CG_ASM("  mov [ebx], eax");
        } else if(peek(CALL)) {
            p_call();
            accept(SCOLON);
        }
        return true;
    }

    bool p_args() {
        p_rval();
        CG_ASM("  push eax");
        while(peek(COMMA)) {
            p_args_tail();
            CG_ASM("  push eax");
        }
        return true;
    }

    bool p_factor() {
        if(peek(LNOT)) {
            accept(LNOT);
            p_rval();
            CG_ASM("  not eax");
            return true;
        }
        if(peek(BNOT)) {
            accept(BNOT);
            p_rval();
            CG_ASM("  not eax");
            return true;
        }
        if(peek(INT_CONST)) {
            CG_ASM("  mov eax, %d", curr().integer);            
            accept(INT_CONST);
            return true;
        }
        if(peek(STR_CONST)) {
            CG_ASM("  mov eax, str_const_%d", curr().strIndex);
            str_consts.insert(curr().strIndex);
            accept(STR_CONST);
            return true;
        }
        if(peek(BOOL_CONST)) {
            CG_ASM("  mov eax, %d", curr().integer);
            accept(BOOL_CONST);
            return true;
        }
        if(peek(THIS)) {
            accept(THIS);
            const Method& m = sc.getMethod(className, methodName);
            CG_ASM("  mov eax, [ebp+%d]", (m.params.size()+2)*WORD_SIZE); // this pointer is the last argument
            return true;
        }
        return Parser::p_factor();
    }

    bool p_while_expr() {
        int uid = uniqueId++;
        ctrlBegin = FmtString("loop_%d", uid);
        ctrlEnd = FmtString("loop_%d_end", uid);
        accept(WHILE);
        accept(LPARENTH);        
        CG_ASM("loop_%d:", uid);
        p_rval();
        CG_ASM("  cmp eax, 1");
        CG_ASM("  jl loop_%d_end", uid);
        accept(RPARENTH);
        p_block();
        CG_ASM("  jmp loop_%d", uid);
        CG_ASM("loop_%d_end:", uid);
        ctrlBegin = ctrlEnd = "";
        return true;
    }

    bool p_return_expr() {
        Parser::p_return_expr();
        CG_ASM("  jmp %s_%s_end", className.c_str(), methodName.c_str());
        return true;
    }

    bool p_if_expr() {
        int uid = uniqueId++;
        accept(IF);
        accept(LPARENTH);
        p_rval();
        accept(RPARENTH);
        CG_ASM("  cmp eax, 1");
        CG_ASM("  jl cond_%d_else", uid);
        p_block();
        CG_ASM("  jmp cond_%d_end", uid);
        CG_ASM("cond_%d_else:", uid);
        if(peek(ELSE)) p_else_block();
        CG_ASM("cond_%d_end:", uid);
        return true;
    }

    // eax: 0 - false, 1 - true
    #define LOGIC_JMP(name, op) {\
        CG_ASM("  cmp ebx, eax");\
        CG_ASM("  "op" logic_"name"_%d", uid);\
        CG_ASM("  xor eax, eax");\
        CG_ASM("  jmp logic_"name"_%d_end", uid);\
        CG_ASM("logic_"name"_%d:", uid);\
        CG_ASM("  mov eax, 1");\
        CG_ASM("logic_"name"_%d_end:", uid);\
    }

    bool p_logic_tail() {
        TokenType op = curr().type;
        int uid = uniqueId++;
        p_logic_op();
        CG_ASM("  push eax");
        p_rval_tail();
        CG_ASM("  pop ebx");        
        switch(op) {
        case EQ:
            LOGIC_JMP("eq", "je");
            break;
        case NEQ:
            LOGIC_JMP("neq", "jne");
            break;
        case LT:
            LOGIC_JMP("lt", "jl");
            break;
        case GT:
            LOGIC_JMP("gt", "jg");
            break;
        case LTEQ:
            LOGIC_JMP("lteq", "jle");
            break;
        case GTEQ:
            LOGIC_JMP("gteq", "jge");
            break;
        case LAND:
            CG_ASM("  and eax, ebx");
            break;
        case LOR:
            CG_ASM("  or eax, ebx");
            break;
        }
        return true;
    }

    bool p_arithm_tail() {
        TokenType op = curr().type;
        p_arithm_op();
        CG_ASM("  push eax");
        p_rval();
        CG_ASM("  pop ebx");
        switch(op) {
        case ADD:
            CG_ASM("  add eax, ebx");
            break;
        case SUB:
            CG_ASM("  xchg eax, ebx");
            CG_ASM("  sub eax, ebx");
            break;
        case MUL:
            CG_ASM("  imul eax, ebx");
            break;
        case DIV:
            CG_ASM("  xchg eax, ebx");
            CG_ASM("  xor edx, edx"); // clear divident
            CG_ASM("  idiv ebx");
            break;
        case SHL:
            CG_ASM("  xchg eax, ebx");
            CG_ASM("  shl eax, ebx");
            break;
        case SHR:
            CG_ASM("  xchg eax, ebx");
            CG_ASM("  shr eax, ebx");
            break;
        case BOR:
            CG_ASM("  or eax, ebx");
            break;
        case BAND:
            CG_ASM("  and eax, ebx");
            break;
        case BXOR:
            CG_ASM("  xor eax, ebx");
            break;
        }
        return true;
    }

    bool p_asm_expr() {
        accept(ASM);
        accept(LPARENTH);
        CG_ASM("%s", curr().strVal().c_str());
        accept(STR_CONST);
        accept(RPARENTH);
        accept(SCOLON);
        return true;
    }

    bool p_var_decl() {
        accept(TYPE);
        const std::string& id = curr().strVal();        
        accept(ID);        
        const Method& m = sc.getMethod(className, methodName);
        if(peek(ASSIGN)) {
            p_initialization();
            CG_ASM("  mov [ebp-%d], eax", (m.localOffset(id)+2)*WORD_SIZE);
        }
        while(peek(COMMA)) {
            accept(COMMA);
            const std::string& id = curr().strVal();
            accept(ID);
            if(peek(ASSIGN)) {
                p_initialization();
                CG_ASM("  mov [ebp-%d], eax", (m.localOffset(id)+2)*WORD_SIZE);
            }
        }
        accept(SCOLON);
        return true;
    }

    bool p_method() {
        accept(DEF);
        accept(TYPE);
        methodName = curr().strVal();
        blockNo = 0;
        CG_ASM("%s_%s:", className.c_str(), methodName.c_str());
        CG_ASM("  push ebp");
        CG_ASM("  mov ebp, esp");
        accept(ID);
        accept(LPARENTH);
        if(peek(TYPE)) p_params();
        accept(RPARENTH);
        const Method& m = sc.getMethod(className, methodName);
        CG_ASM("  push method_%s_%s_tag", className.c_str(), methodName.c_str()); // method desc used by GC
        if(m.local_vars.size() > 0)
            CG_ASM("  sub esp, %d", m.local_vars.size() * WORD_SIZE); // local vars
        p_block();
        CG_ASM("%s_%s_end:", className.c_str(), methodName.c_str());
        CG_ASM("  mov esp, ebp");
        CG_ASM("  pop ebp");
        CG_ASM("  ret\n");
        methodName = "";
        return true;
    }

    bool p_program() {
        CG_ASM("format PE console");
        CG_ASM("entry _start");
        CG_ASM("include 'd:\\fasm\\INCLUDE\\win32a.inc'");
        CG_ASM("");
        CG_ASM("section '.text' code readable executable");

        const Class& entry = sc.getClass(sc.getEntryPoint().first);

        CG_ASM("_start:");
        CG_ASM("  xor ebp, ebp"); // zero frame pointer
        CG_ASM("  push class_tags");
        CG_ASM("  call [gc_init]");
        CG_ASM("  add esp, %d", WORD_SIZE);
        CG_ASM("  push %d", sc.getClassTag(entry.name));
        CG_ASM("  push ebp");
        CG_ASM("  call [gc_malloc]");
        CG_ASM("  add esp, %d", 2*WORD_SIZE);
        CG_ASM("  push eax"); // pointer to class instance
        CG_ASM("  push 0"); // argc
        CG_ASM("  push 0"); // argv
        CG_ASM("  call %s_%s", sc.getEntryPoint().first.c_str(), sc.getEntryPoint().second.c_str());
        CG_ASM("  add esp, 12"); // pop args
        CG_ASM("  ret\n");

        while(peek(CLASS))
            p_class_def();

        CG_ASM("section '.data' data readable writeable");
        for(auto sIt = str_consts.begin(); sIt != str_consts.end(); sIt++) // string constants
            CG_ASM("str_const_%d db \"%s\", 0", *sIt , Token::st.get(*sIt).c_str());

        // description of classes used by GC (called tags)
        // number of attributes nd info if they are refrences or values
        CG_ASM("class_tags:");
        for(auto cIt = sc.getClasses().cbegin(); cIt != sc.getClasses().cend(); cIt++) {
            const std::string& cName = cIt->first;
            const Class& c = cIt->second;            
            unsigned int mask = 0;
            for(auto aIt = c.attributes.cbegin(); aIt != c.attributes.end(); aIt++) {
                mask <<= 1;
                const Var& attr = aIt->second;
                if(attr.type != "Int" && attr.type != "Bool")
                    mask |= 1;                
            }
            CG_ASM("  class_%s_tag dd %u, %u", cName.c_str(), c.attributes.size(), mask);            
        }

        // description of classes methods also used by GC (called tags)
        // number of local variables and arguments and info if they are refrences or values
        CG_ASM("method_tags:");
        for(auto cIt = sc.getClasses().cbegin(); cIt != sc.getClasses().cend(); cIt++) {
            const std::string& cName = cIt->first;
            const Class& c = cIt->second;
            for(auto mIt = c.methods.cbegin(); mIt != c.methods.cend(); mIt++) {
                const std::string& mName = mIt->first;
                const Method& m = mIt->second;
                unsigned int loc_mask = 0;
                for(auto lIt = m.local_vars.cbegin(); lIt != m.local_vars.end(); lIt++) {
                    loc_mask <<= 1;
                    const Var& local = lIt->second;
                    if(local.type != "Int" && local.type != "Bool")
                        loc_mask |= 1;                
                }
                unsigned int arg_mask = 0;
                for(auto aIt = m.params.cbegin(); aIt != m.params.end(); aIt++) {
                    arg_mask <<= 1;
                    const Var& arg = aIt->second;
                    if(arg.type != "Int" && arg.type != "Bool")
                        arg_mask |= 1;                
                }
                CG_ASM("  method_%s_%s_tag dd %u, %u, %u, %u", cName.c_str(), mName.c_str(),
                    m.local_vars.size(), loc_mask, m.params.size(), arg_mask);
            }
        }

        CG_ASM("");
        CG_ASM("section '.idata' data readable import"); // imports
        CG_ASM("library msvcrt, 'msvcrt.dll', gc, 'gc.dll'");
        CG_ASM("import msvcrt, printf, 'printf', puts, 'puts', scanf, 'scanf', itoa, 'itoa', sprintf, 'sprintf'");
        CG_ASM("import gc, gc_init, 'gc_init', gc_malloc, 'gc_malloc'");

        return true;
    }

    bool p_for_expr() {
        int uid = uniqueId++;
        ctrlBegin = FmtString("loop_%d_post_block", uid);
        ctrlEnd = FmtString("loop_%d_end", uid);
        accept(FOR);
        accept(LPARENTH);
        p_ptr_expr();
        CG_ASM("loop_%d:", uid);
        p_rval();
        CG_ASM("  cmp eax, 1");
        CG_ASM("  jl loop_%d_end", uid);
        CG_ASM("  jmp loop_%d_block", uid);
        accept(SCOLON);
        CG_ASM("loop_%d_post_block:", uid);
        p_block();
        CG_ASM("  jmp loop_%d", uid);
        accept(RPARENTH);
        CG_ASM("loop_%d_block:", uid);
        p_block();
        CG_ASM("  jmp loop_%d_post_block", uid);
        CG_ASM("loop_%d_end:", uid);
        ctrlBegin = ctrlEnd = "";
        return true;
    }

    bool p_ctrl_expr() {
        if(peek(BREAK))
            CG_ASM("  jmp %s", ctrlEnd.c_str());
        else if(peek(CONTINUE))
            CG_ASM("  jmp %s", ctrlBegin.c_str());
        return Parser::p_ctrl_expr();
    }

    bool p_alloc() {
        accept(NEW);
        const Class& c = sc.getClass(curr().strVal());
        accept(TYPE);
        CG_ASM("  push %d", sc.getClassTag(c.name));
        CG_ASM("  push ebp");
        CG_ASM("  call [gc_malloc]");
        CG_ASM("  add esp, %d", 2*WORD_SIZE);
        for(auto aIt = c.attributes.cbegin(); aIt != c.attributes.cend(); aIt++) { // initialize attributes that are pointers to 0
            const Var& att = aIt->second;
            if(att.type != "Int" && att.type != "Bool")
                CG_ASM("  mov [eax+%d], dword 0", c.attribOffset(aIt->first)*WORD_SIZE);
        }
        return true;
    }

    bool p_switch_expr() {
        int uid = uniqueId++;
        ctrlEnd = FmtString("cond_%d_end", uid);
        accept(SWITCH);
        accept(LPARENTH);
        p_rval();
        CG_ASM("  mov ecx, eax");
        accept(RPARENTH);
        accept(LBRACE);
        while(peek(CASE)) {
            accept(CASE);
            int caseId = curr().integer;
            CG_ASM("  cmp ecx, %d", caseId);
            CG_ASM("  jne cond_%d_%d_next", uid, caseId);
            accept(INT_CONST);
            accept(COLON);
            p_block();
            CG_ASM("  jmp cond_%d_end", uid);
            CG_ASM("cond_%d_%d_next:", uid, caseId);
        }
        if(peek(DEFAULT))
            p_default_case();
        accept(RBRACE);
        CG_ASM("cond_%d_end:", uid);
        ctrlEnd = "";
        return true;
    }
};

int CodeGen::uniqueId = 1;

int main() {
    std::ifstream f("code.mm");
    std::string code((std::istreambuf_iterator<char>(f)), std::istreambuf_iterator<char>());
    f.close();

    if(SemanticCheck().parse(code)) {
        FILE* out = fopen("code.s", "w");
        std::cout << CodeGen(out).parse(code) << std::endl;
        fclose(out);
        return 1;
    }

    return 0;
}

#endif
