from gen_parser import GRAMMAR, Terminals, is_term, non_term_name
from gen_lexer import tab

CODE = '''/* autogenerated by codegen.py, code generation assumes that AST is correct */
#ifndef __CODEGEN_H__
#define __CODEGEN_H__

#include "SemanticCheck.h"

#define CG_ASM(fmt, ...) fprintf(out, fmt "\\n", __VA_ARGS__)

class CodeGen : public Parser {
    FILE* out;
    static int uniqueId;

    /* for break and continue, TODO: add to semantic checker */
    std::string ctrlEnd, ctrlBegin;

    SemanticCheck sc;

    /* processor word size in bytes */
    static const int WORD_SIZE = 4;
public:
    CodeGen(FILE* _out) : out(_out) { }

    bool parse(const std::string& str) {
        return sc.parse(str) && Parser::parse(str);
    }
protected:
    // local variable or method argument
    std::string getVarAddr(const std::string& clazz, const std::string& method, const std::string& id, int offset) {
        if(sc.isLocalVar(clazz, method, id)) {
            if(offset == -1)
                return FmtString("var_%%s_%%s_%%s", clazz.c_str(), method.c_str(), id.c_str());
            else
                return FmtString("var_%%s_%%s_%%s+%%d", clazz.c_str(), method.c_str(), id.c_str(), offset*WORD_SIZE);
        }
        if(sc.isMethodArg(clazz, method, id)) {
            const Method& m = sc.getMethod(clazz, method);
            return FmtString("ebp+%%d", (m.paramOffset(id)+3) * WORD_SIZE, id.c_str()); // 1 word for return addr, 1 for prev ebp, 1 for this pointer
        }
        return "???";
    }

    int getInstanceSize(const std::string& clazz) {
        if(clazz == "Int" || clazz == "Void" || clazz == "Bool")
            return WORD_SIZE;

        if(clazz == "Byte")
            return 1;

        int size = 0;
        const auto &atts = sc.getClasses().at(clazz).attributes;
        for(auto aIt = atts.begin(); aIt != atts.end(); aIt++)
            size += aIt->second.size * WORD_SIZE;
        return size;
    }
%s
};

int CodeGen::uniqueId = 1;

int main() {
    std::ifstream f("code.mm");
    std::string code((std::istreambuf_iterator<char>(f)), std::istreambuf_iterator<char>());
    f.close();

    if(SemanticCheck().parse(code)) {
        FILE* out = fopen("code.s", "w");
        std::cout << CodeGen(out).parse(code) << std::endl;
        fclose(out);
        return 1;
    }

    return 0;
}

#endif'''

# appended after symbol is accepted
ACTIONS = {
    'class_def': {
        'CLASS': '%sclassName = curr().strVal();' % tab(2),
        'RBRACE': '%sclassName = "";' % tab(2)
    },
    'method': {
        'TYPE': '%smethodName = curr().strVal();' % tab(2),
        'block': '%smethodName = "";' % tab(2)
    },
    'block': {
        'LBRACE': '%sblockNo++;' % tab(2)
    }
}

def generate():
    code = ''
    for product in GRAMMAR:
        code += '%sbool p_%s() {\n' % (tab(), product)
        for alternative in GRAMMAR[product]:
            code += '%sif(%s) {\n' % (tab(2), Terminals(alternative[0]).cond())
            for symbol in alternative:
                if is_term(symbol):
                    code += '%saccept(%s);\n' % (tab(3), symbol)
                elif symbol.endswith('*'):
                    symbol = non_term_name(symbol)
                    code += '%swhile(%s) {\n' % (tab(3), Terminals(non_term_name(symbol)).cond())
                    code += '%sp_%s();\n' % (tab(4), symbol)
                    code += '%s}\n' % tab(3)
                elif symbol.endswith('?'):
                    symbol = non_term_name(symbol)
                    code += '%sif(%s) p_%s();\n' % (tab(3), Terminals(non_term_name(symbol)).cond(), symbol)
                else:
                    code += '%sp_%s();\n' % (tab(3), symbol)
                if product in ACTIONS and symbol in ACTIONS[product]:
                    code += ACTIONS[product][symbol] + '\n'
            code += '%sreturn true;\n%s}\n' % (tab(3), tab(2))
        code += '%sreturn true;\n%s}\n\n' % (tab(2), tab(1))
    print(CODE % code)

if __name__ == '__main__':
    generate()